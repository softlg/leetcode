package lc.rating;

public class T997_找到小镇的法官 {
    /*
    难度：easy
    --------------------------------------------------------------------------------
    题目：
        小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。

        如果小镇法官真的存在，那么：

        小镇法官不会信任任何人。
        每个人（除了小镇法官）都信任这位小镇法官。
        只有一个人同时满足属性 1 和属性 2 。
        给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。

        如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。
    --------------------------------------------------------------------------------
    解题思路：
        1.如果存在法官，那么所有人都会信任法官，在结合条件1，可以得出信任法官的人数为n-1。
        2.如果不存在法官，那么也可能存在某些人被所有人信任，这个人的信任人数也为n-1，但是他也会信任别人。
        3.可以以此作为区分other和juage的条件，假设每个人都有信任值，那么定义一个数组长度为n，用来存放n个人的信任值:
        1)如果一个人信任了别人，那么将这个人的信任值-1
        2）如果一个人被别人信任，那么这个人的信任值＋1

        当一个人被所有人信任，并且他没有信任其它人时，这个人的信任值就是n- 1，那么此人就是法官。
        当一个人被所有人信任，但是他也信任了其他人时，这个人的信任值<n - 1。
        其它情况下，每个人的信任值都会小于n -1。
    --------------------------------------------------------------------------------
     */

    public static int findJudge(int n, int[][] trust) {
        // 定义数组用于存放每个人的信任值
        // 人员编号从1开始，这里+1防止后续计算麻烦
        int[] trustValues = new int[n + 1];
        // 遍历trust数组计算每个人的信任值
        for(int[] t : trust){
            trustValues[t[0]]--;
            trustValues[t[1]]++;
        }
        // 遍历这n个人的信任值，如果存在 n - 1，则返回这个人的编号
        for(int i =1; i <= n;i++){
            if(trustValues[i] == (n - 1)) return i;
        }
        return -1;
    }

}
